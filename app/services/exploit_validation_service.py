import reflex as rx
import logging
import asyncio
import docker
from docker.errors import APIError, ImageNotFound, ContainerError
from pymetasploit3.msfrpc import MsfRpcClient
from typing import Optional, Any
from app.utils import supabase_client

logger = logging.getLogger(__name__)


class ExploitValidationService:
    """Service to validate exploit proofs in a sandboxed environment."""

    def __init__(self, metasploit_host: str, metasploit_pass: str):
        try:
            self.docker_client = docker.from_env()
        except Exception as e:
            logger.exception(f"Failed to connect to Docker daemon: {e}")
            self.docker_client = None
        try:
            self.msf_client = MsfRpcClient(
                password=metasploit_pass, server=metasploit_host, port=55552, ssl=False
            )
        except Exception as e:
            logger.exception(f"Failed to connect to Metasploit RPC server: {e}")
            self.msf_client = None

    async def validate_exploit_proof(self, proof: dict) -> dict:
        """Orchestrates the validation of a single exploit proof."""
        if not self.docker_client or not self.msf_client:
            return {"status": "failure", "logs": "Infrastructure not ready."}
        proof_id = proof.get("id")
        target_image = self._get_target_image_for_proof(proof)
        if not target_image:
            return {"status": "failure", "logs": "No suitable target image found."}
        container = None
        try:
            await supabase_client.create_exploit_validation_record(
                proof_id, "metasploit", "started"
            )
            logger.info(f"Pulling target image: {target_image}")
            try:
                self.docker_client.images.pull(target_image)
            except ImageNotFound as e:
                logger.exception(
                    f"Target image {target_image} not found in Docker Hub: {e}"
                )
                await supabase_client.update_exploit_validation_record(
                    proof_id, "failure", {"error": "Image not found"}
                )
                return {"status": "failure", "logs": f"Image {target_image} not found."}
            logger.info(f"Running container for image: {target_image}")
            container = self.docker_client.containers.run(
                target_image, detach=True, ports={"80/tcp": None}
            )
            await asyncio.sleep(10)
            container.reload()
            target_ip = container.attrs["NetworkSettings"]["IPAddress"]
            logger.info(f"Executing Metasploit module against {target_ip}")
            validation_result = self._run_metasploit_module(proof, target_ip)
            await supabase_client.update_exploit_validation_record(
                proof_id, validation_result["status"], validation_result["evidence"]
            )
            return validation_result
        except (APIError, ContainerError) as e:
            logger.exception(f"Docker error during validation: {e}")
            await supabase_client.update_exploit_validation_record(
                proof_id, "failure", {"error": str(e)}
            )
            return {"status": "failure", "logs": str(e)}
        finally:
            if container:
                logger.info(f"Stopping and removing container {container.id}")
                container.stop()
                container.remove()

    def _get_target_image_for_proof(self, proof: dict) -> Optional[str]:
        """Determines the appropriate Docker image to use as a target."""
        title = proof.get("title", "").lower()
        if "apache" in title:
            return "httpd:2.4.48"
        if "vsftpd" in title:
            return "metasploitable3"
        return None

    def _run_metasploit_module(self, proof: dict, target_ip: str) -> dict:
        """Executes a Metasploit module and captures evidence."""
        module_name = proof.get("proof_type")
        if not module_name:
            return {
                "status": "failure",
                "logs": "No Metasploit module specified in proof.",
            }
        try:
            exploit = self.msf_client.modules.use("exploit", module_name)
            exploit["RHOSTS"] = target_ip
            job_info = exploit.execute(payload="cmd/unix/interact")
            job_id = job_info["job_id"]
            session_established = False
            for _ in range(10):
                if self.msf_client.jobs.info(job_id)["status"] == "completed":
                    sessions = self.msf_client.sessions.list
                    if sessions and any((str(job_id) in s for s in sessions)):
                        session_established = True
                        break
                asyncio.sleep(2)
            if session_established:
                session_id = list(self.msf_client.sessions.list.keys())[0]
                shell = self.msf_client.sessions.session(session_id)
                shell.write("whoami")
                shell.write("id")
                output = shell.read()
                return {
                    "status": "confirmed",
                    "logs": f"Successfully exploited {target_ip} with {module_name}.\n{output}",
                    "evidence": {
                        "session_id": session_id,
                        "console_output": output,
                        "target_ip": target_ip,
                    },
                }
            else:
                return {
                    "status": "failure",
                    "logs": f"Exploit did not result in a session for job {job_id}",
                    "evidence": {"job_id": job_id},
                }
        except Exception as e:
            logger.exception(f"Metasploit execution failed: {e}")
            return {"status": "failure", "logs": str(e)}