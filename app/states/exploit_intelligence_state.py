import reflex as rx
from typing import TypedDict, Optional, Literal
import logging
from app.utils import supabase_client
from app.state import AppState
import asyncio
import random
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


class ExploitProof(TypedDict):
    id: int
    cve_id: str
    title: str
    source: str
    maturity_level: Literal["poc", "functional", "weaponized"]
    validation_status: Literal["pending", "validating", "confirmed", "failed"]
    confidence_score: float
    affected_products: list[str]
    mitre_ttps: list[str]
    description: str
    exploit_code: Optional[str]
    validation_evidence: Optional[dict]
    created_at: str
    validated_at: Optional[str]


class ExploitIntelligenceState(rx.State):
    """Manages the Exploit Intelligence page and validation workflows."""

    proofs: list[ExploitProof] = []
    filtered_proofs: list[ExploitProof] = []
    is_loading: bool = False
    selected_proof: Optional[ExploitProof] = None
    show_detail_modal: bool = False
    is_validating: set[int] = set()
    validation_status_filter: list[str] = []
    maturity_level_filter: list[str] = []
    source_filter: list[str] = []
    search_query: str = ""

    @rx.event(background=True)
    async def load_exploit_proofs(self):
        """Load all exploit proofs from the database."""
        async with self:
            self.is_loading = True
        try:
            await asyncio.sleep(1.5)
            mock_proofs = []
            statuses = ["pending", "validating", "confirmed", "failed"]
            maturities = ["poc", "functional", "weaponized"]
            sources = ["otx", "vulncheck", "metasploit"]
            for i in range(50):
                status = random.choice(statuses)
                mock_proofs.append(
                    {
                        "id": i,
                        "cve_id": f"CVE-2024-1{i:03}",
                        "title": f"Remote Code Execution in WebServer {i}",
                        "source": random.choice(sources),
                        "maturity_level": random.choice(maturities),
                        "validation_status": status,
                        "confidence_score": round(random.uniform(0.5, 1.0), 2),
                        "affected_products": ["WebServer 1.2.3"],
                        "mitre_ttps": ["T1210"],
                        "description": "A detailed description of the exploit proof...",
                        "exploit_code": "print('exploited')" if i % 3 == 0 else None,
                        "validation_evidence": {"console_output": "root# whoami"}
                        if status == "confirmed"
                        else None,
                        "created_at": (datetime.now() - timedelta(days=i)).isoformat(),
                        "validated_at": (
                            datetime.now() - timedelta(days=i - 1)
                        ).isoformat()
                        if status in ["confirmed", "failed"]
                        else None,
                    }
                )
            async with self:
                self.proofs = mock_proofs
                self._apply_filters()
        except Exception as e:
            logger.exception("Failed to load exploit proofs.")
        finally:
            async with self:
                self.is_loading = False

    def _apply_filters(self):
        """Apply all active filters to the list of proofs."""
        proofs_to_filter = self.proofs
        if self.search_query:
            query = self.search_query.lower()
            proofs_to_filter = [
                p
                for p in proofs_to_filter
                if query in p["cve_id"].lower() or query in p["title"].lower()
            ]
        if self.validation_status_filter:
            proofs_to_filter = [
                p
                for p in proofs_to_filter
                if p["validation_status"] in self.validation_status_filter
            ]
        if self.maturity_level_filter:
            proofs_to_filter = [
                p
                for p in proofs_to_filter
                if p["maturity_level"] in self.maturity_level_filter
            ]
        if self.source_filter:
            proofs_to_filter = [
                p for p in proofs_to_filter if p["source"] in self.source_filter
            ]
        self.filtered_proofs = proofs_to_filter

    @rx.event
    def set_search_query(self, query: str):
        self.search_query = query
        self._apply_filters()

    @rx.event
    def toggle_filter(self, filter_list_name: str, value: str):
        current_filter_list = getattr(self, filter_list_name)
        if value in current_filter_list:
            current_filter_list.remove(value)
        else:
            current_filter_list.append(value)
        setattr(self, filter_list_name, current_filter_list)
        self._apply_filters()

    @rx.event
    def clear_filters(self):
        self.validation_status_filter = []
        self.maturity_level_filter = []
        self.source_filter = []
        self.search_query = ""
        self._apply_filters()

    @rx.event
    def open_proof_details(self, proof: ExploitProof):
        self.selected_proof = proof
        self.show_detail_modal = True

    @rx.event
    def close_proof_details(self):
        self.show_detail_modal = False
        self.selected_proof = None

    @rx.event(background=True)
    async def trigger_validation(self, proof_id: int):
        """Trigger the validation workflow for a specific proof."""
        from app.states.proof_validation_state import ProofValidationState

        async with self:
            self.is_validating.add(proof_id)
        try:
            async with self:
                validation_state = await self.get_state(ProofValidationState)
                await validation_state.start_validation_for_proof(proof_id)
            await self.load_exploit_proofs()
        except Exception as e:
            logger.exception(f"Error triggering validation for proof {proof_id}: {e}")
            yield rx.toast.error("Failed to start validation.")
        finally:
            async with self:
                if proof_id in self.is_validating:
                    self.is_validating.remove(proof_id)